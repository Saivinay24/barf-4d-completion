<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BARF 4D — Web Viewer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #0a0a0f;
      color: #e0e0e0;
      font-family: 'Courier New', monospace;
      overflow: hidden;
    }

    #canvas-container { position: fixed; inset: 0; }
    canvas { display: block; }

    /* HUD */
    #hud {
      position: fixed;
      top: 0; left: 0; right: 0;
      padding: 16px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(0,0,0,0.75), transparent);
      pointer-events: none;
      z-index: 10;
    }
    #hud h1 {
      font-size: 13px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: #ff4444;
    }
    #hud .status {
      font-size: 11px;
      color: #666;
      letter-spacing: 0.1em;
    }

    /* Mode indicator top-left */
    #mode-indicator {
      position: fixed;
      top: 56px;
      left: 24px;
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      padding: 5px 10px;
      border: 1px solid #333;
      color: #555;
      z-index: 10;
      transition: all 0.3s;
      pointer-events: none;
    }
    #mode-indicator.completed {
      border-color: #44ff88;
      color: #44ff88;
    }

    /* Info top-right */
    #info {
      position: fixed;
      top: 56px;
      right: 24px;
      font-size: 10px;
      color: #3a3a3a;
      letter-spacing: 0.08em;
      line-height: 1.9;
      z-index: 10;
      pointer-events: none;
    }

    /* Split view labels */
    #split-label-left, #split-label-right {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      font-size: 9px;
      letter-spacing: 0.25em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.18);
      z-index: 11;
      pointer-events: none;
      display: none;
      writing-mode: vertical-rl;
    }
    #split-label-left  { left: 10px; }
    #split-label-right { right: 10px; transform: translateY(-50%) rotate(180deg); }

    /* Split divider line */
    #split-divider {
      display: none;
      position: fixed;
      top: 0; bottom: 0;
      left: 50%;
      width: 1px;
      background: rgba(255,255,255,0.08);
      z-index: 11;
      pointer-events: none;
    }

    /* Timeline */
    #timeline {
      position: fixed;
      bottom: 76px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 14px;
      z-index: 10;
      background: rgba(10,10,15,0.88);
      border: 1px solid rgba(255,255,255,0.07);
      padding: 10px 20px;
      min-width: 440px;
    }
    #timeline label {
      font-size: 9px;
      color: #3a3a3a;
      letter-spacing: 0.15em;
      white-space: nowrap;
    }
    #frame-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 2px;
      background: #1e1e1e;
      outline: none;
      cursor: pointer;
    }
    #frame-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 10px; height: 10px;
      background: #ff4444;
      cursor: pointer;
      border-radius: 0;
    }
    #frame-slider:disabled { opacity: 0.2; cursor: default; }
    #frame-display {
      font-size: 10px;
      color: #444;
      letter-spacing: 0.08em;
      min-width: 70px;
      text-align: right;
    }
    #play-btn { padding: 4px 12px; font-size: 10px; }
    #play-btn.playing { border-color: #ff4444; color: #ff4444; }

    /* Controls */
    #controls {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      z-index: 10;
    }

    button {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.12);
      color: #888;
      padding: 8px 16px;
      font-family: 'Courier New', monospace;
      font-size: 10px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.15s;
      white-space: nowrap;
    }
    button:hover {
      background: rgba(255,68,68,0.12);
      border-color: #ff4444;
      color: #fff;
    }
    button.active {
      background: rgba(255,68,68,0.18);
      border-color: #ff4444;
      color: #ff4444;
    }

    /* File loader */
    #loader {
      position: fixed;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      z-index: 20;
      transition: opacity 0.5s;
    }
    #loader h2 {
      font-size: 10px;
      letter-spacing: 0.3em;
      text-transform: uppercase;
      color: #444;
      margin-bottom: 20px;
    }
    #loader label {
      display: inline-block;
      padding: 12px 28px;
      border: 1px solid #ff4444;
      color: #ff4444;
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      cursor: pointer;
      transition: all 0.2s;
    }
    #loader label:hover { background: rgba(255,68,68,0.08); }
    #loader input { display: none; }
    #loader .hint {
      margin-top: 14px;
      font-size: 9px;
      color: #2a2a2a;
      letter-spacing: 0.1em;
    }
    #loader .hint2 {
      margin-top: 6px;
      font-size: 9px;
      color: #2a2a2a;
      letter-spacing: 0.1em;
    }
  </style>
</head>
<body>

<div id="canvas-container"></div>

<div id="hud">
  <h1>BARF 4D Viewer</h1>
  <span class="status" id="status">No file loaded</span>
</div>

<div id="mode-indicator">PARTIAL</div>

<div id="info">
  Drag — orbit<br>
  Scroll — zoom<br>
  Right drag — pan<br>
  C — before / after<br>
  S — split view
</div>

<div id="split-label-left">PARTIAL</div>
<div id="split-label-right">COMPLETED</div>
<div id="split-divider"></div>

<div id="loader">
  <h2>Point Cloud Viewer</h2>
  <label>
    Load .ply file
    <input type="file" id="fileInput" accept=".ply,.json" multiple />
  </label>
  <div class="hint">drop .ply to load point cloud</div>
  <div class="hint2">drop second .ply for before/after · drop .json to reload gaps</div>
</div>

<div id="timeline">
  <label>FRAME</label>
  <input type="range" id="frame-slider" min="0" max="0" value="0" disabled />
  <span id="frame-display">— / —</span>
  <button id="play-btn">▶ Play</button>
</div>

<div id="controls">
  <button id="toggleGaps" class="active">Gaps ON</button>
  <button id="toggleComplete">Before / After &nbsp;[C]</button>
  <button id="toggleSplit">Split View &nbsp;[S]</button>
  <button id="resetCamera">Reset View</button>
</div>

<script>
// ─── PLY Parser ───────────────────────────────────────────────────────────────
async function parsePLY(buffer) {
  const headerText = new TextDecoder().decode(buffer.slice(0, 4096));
  const headerEndIdx = headerText.indexOf('end_header');
  if (headerEndIdx === -1) throw new Error('Invalid PLY: no end_header');
  // Find actual byte offset of end_header (handle multi-byte chars)
  const headerBytes = new TextEncoder().encode(headerText.substring(0, headerEndIdx + 'end_header'.length));
  const headerEnd = headerBytes.length + 1; // +1 for newline

  const vertexCountMatch = headerText.match(/element vertex (\d+)/);
  if (!vertexCountMatch) throw new Error('No vertex count in PLY header');
  const vertexCount = parseInt(vertexCountMatch[1]);

  // Parse properties to determine stride and offsets
  const propLines = headerText.split('\n').filter(l => l.startsWith('property'));
  let stride = 0;
  const props = [];
  for (const line of propLines) {
    const parts = line.trim().split(/\s+/);
    const type = parts[1];
    const name = parts[2];
    let size;
    if (type === 'float' || type === 'float32' || type === 'int' || type === 'int32' || type === 'uint') size = 4;
    else if (type === 'double' || type === 'float64') size = 8;
    else if (type === 'uchar' || type === 'uint8' || type === 'char' || type === 'int8') size = 1;
    else if (type === 'short' || type === 'int16' || type === 'ushort' || type === 'uint16') size = 2;
    else size = 4;
    props.push({ name, type, offset: stride, size });
    stride += size;
  }

  // Find key property offsets
  const getProp = (name) => props.find(p => p.name === name);
  const xProp = getProp('x'), yProp = getProp('y'), zProp = getProp('z');
  const rProp = getProp('red'), gProp = getProp('green'), bProp = getProp('blue');

  if (!xProp || !yProp || !zProp) throw new Error('PLY missing x/y/z properties');

  const dataView = new DataView(buffer, headerEnd);
  const points = new Float32Array(vertexCount * 3);
  const colors = new Float32Array(vertexCount * 3);

  for (let i = 0; i < vertexCount; i++) {
    const base = i * stride;
    points[i * 3]     = dataView.getFloat32(base + xProp.offset, true);
    points[i * 3 + 1] = dataView.getFloat32(base + yProp.offset, true);
    points[i * 3 + 2] = dataView.getFloat32(base + zProp.offset, true);

    if (rProp && gProp && bProp) {
      if (rProp.size === 1) {
        colors[i * 3]     = dataView.getUint8(base + rProp.offset) / 255;
        colors[i * 3 + 1] = dataView.getUint8(base + gProp.offset) / 255;
        colors[i * 3 + 2] = dataView.getUint8(base + bProp.offset) / 255;
      } else {
        colors[i * 3]     = dataView.getFloat32(base + rProp.offset, true);
        colors[i * 3 + 1] = dataView.getFloat32(base + gProp.offset, true);
        colors[i * 3 + 2] = dataView.getFloat32(base + bProp.offset, true);
      }
    } else {
      colors[i * 3] = colors[i * 3 + 1] = colors[i * 3 + 2] = 0.7;
    }
  }
  return { points, colors, vertexCount };
}

// ─── Three.js Setup ───────────────────────────────────────────────────────────
const container = document.getElementById('canvas-container');
const renderer  = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0a0a0f);
container.appendChild(renderer.domElement);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 1000);
camera.position.set(0, 0, 5);

// ─── Orbit Controls ───────────────────────────────────────────────────────────
let isDragging = false, isRightDrag = false;
let prevMouse  = { x: 0, y: 0 };
let spherical  = { theta: 0, phi: Math.PI / 2, radius: 5 };
let target     = new THREE.Vector3();

renderer.domElement.addEventListener('mousedown', e => {
  isDragging = true;
  isRightDrag = e.button === 2;
  prevMouse = { x: e.clientX, y: e.clientY };
});
renderer.domElement.addEventListener('contextmenu', e => e.preventDefault());
window.addEventListener('mouseup', () => isDragging = false);
window.addEventListener('mousemove', e => {
  if (!isDragging) return;
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;
  if (isRightDrag) {
    const speed = 0.002 * spherical.radius;
    const right = new THREE.Vector3();
    camera.getWorldDirection(right);
    right.cross(camera.up).normalize();
    target.addScaledVector(right, -dx * speed);
    target.addScaledVector(camera.up, dy * speed);
  } else {
    spherical.theta -= dx * 0.005;
    spherical.phi = Math.max(0.05, Math.min(Math.PI - 0.05, spherical.phi - dy * 0.005));
  }
  prevMouse = { x: e.clientX, y: e.clientY };
  updateCamera();
});
renderer.domElement.addEventListener('wheel', e => {
  spherical.radius = Math.max(0.1, spherical.radius * (1 + e.deltaY * 0.001));
  updateCamera();
});

function updateCamera() {
  camera.position.set(
    target.x + spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta),
    target.y + spherical.radius * Math.cos(spherical.phi),
    target.z + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta)
  );
  camera.lookAt(target);
}
updateCamera();

// ─── Gap Visualization ────────────────────────────────────────────────────────
let gapMeshes   = [];
let gapsVisible = true;

const INLINE_GAPS = [
  { center: [3,  2, -2], size: 1.0 },
  { center: [-3,-1,  1], size: 0.5 },
  { center: [0,  3, -3], size: 2.0 }
];

function renderGaps(gaps) {
  gapMeshes.forEach(m => scene.remove(m));
  gapMeshes = [];
  gaps.forEach(gap => {
    const radius   = Math.cbrt(gap.size) * 0.1;
    const geometry = new THREE.SphereGeometry(radius, 16, 16);
    const material = new THREE.MeshBasicMaterial({
      color: new THREE.Color(1, 0, 0),
      opacity: 0.55,
      transparent: true
    });
    const sphere = new THREE.Mesh(geometry, material);
    sphere.position.set(gap.center[0], gap.center[1], gap.center[2]);
    sphere.visible = gapsVisible;
    scene.add(sphere);
    gapMeshes.push(sphere);
  });
}

// Try server first, fall back to inline
(async () => {
  try {
    const res = await fetch('gaps.json');
    if (!res.ok) throw new Error();
    renderGaps(await res.json());
  } catch {
    renderGaps(INLINE_GAPS);
  }
})();

// ─── Point Cloud State ────────────────────────────────────────────────────────
let pointCloud     = null;
let partialCloud   = null;
let completedCloud = null;

function buildCloud(points, colors) {
  const geo = new THREE.BufferGeometry();
  const posArr = (points instanceof Float32Array) ? points : new Float32Array(points);
  const colArr = (colors instanceof Float32Array) ? colors : new Float32Array(colors);
  geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
  geo.setAttribute('color',    new THREE.BufferAttribute(colArr, 3));
  const mat = new THREE.PointsMaterial({ size: 0.015, vertexColors: true, sizeAttenuation: true });
  return new THREE.Points(geo, mat);
}

function renderPointCloud(points, colors, vertexCount, isCompleted) {
  const cloud = buildCloud(points, colors);

  if (!isCompleted) {
    if (partialCloud) scene.remove(partialCloud);
    partialCloud = cloud;
    scene.add(partialCloud);
    pointCloud = partialCloud;

    cloud.geometry.computeBoundingSphere();
    const bs = cloud.geometry.boundingSphere;
    target.copy(bs.center);
    spherical.radius = bs.radius * 2.5;
    updateCamera();

    document.getElementById('loader').style.opacity = '0';
    setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
  } else {
    if (completedCloud) scene.remove(completedCloud);
    completedCloud = cloud;
    completedCloud.visible = false;
    scene.add(completedCloud);
  }

  addFrame(points, colors);
  document.getElementById('status').textContent =
    `${vertexCount.toLocaleString()} pts · ${isCompleted ? 'completed' : 'partial'} loaded`;
}

// ─── Before / After ───────────────────────────────────────────────────────────
let showCompleted = false;

function setMode(completed) {
  if (completed && !completedCloud) {
    document.getElementById('status').textContent = 'Drop a second .ply to load the completed version';
    return;
  }
  showCompleted = completed;
  const ind = document.getElementById('mode-indicator');
  if (completed) {
    if (partialCloud)   partialCloud.visible   = false;
    if (completedCloud) completedCloud.visible = true;
    ind.textContent = 'COMPLETED';
    ind.classList.add('completed');
    document.getElementById('toggleComplete').classList.add('active');
  } else {
    if (completedCloud) completedCloud.visible = false;
    if (partialCloud)   partialCloud.visible   = true;
    ind.textContent = 'PARTIAL';
    ind.classList.remove('completed');
    document.getElementById('toggleComplete').classList.remove('active');
  }
}

document.getElementById('toggleComplete').addEventListener('click', () => setMode(!showCompleted));

// ─── Split View ───────────────────────────────────────────────────────────────
let splitMode = false;

function setSplit(on) {
  splitMode = on;
  document.getElementById('toggleSplit').classList.toggle('active', on);
  document.getElementById('split-label-left').style.display  = on ? 'block' : 'none';
  document.getElementById('split-label-right').style.display = on ? 'block' : 'none';
  document.getElementById('split-divider').style.display     = on ? 'block' : 'none';
  if (!on) {
    renderer.setScissorTest(false);
    renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
  }
}

document.getElementById('toggleSplit').addEventListener('click', () => setSplit(!splitMode));

// ─── Keyboard Shortcuts ───────────────────────────────────────────────────────
document.addEventListener('keydown', e => {
  if (e.target.tagName === 'INPUT') return;
  if (e.key === 'c' || e.key === 'C') setMode(!showCompleted);
  if (e.key === 's' || e.key === 'S') setSplit(!splitMode);
});

// ─── Gaps Toggle ─────────────────────────────────────────────────────────────
document.getElementById('toggleGaps').addEventListener('click', function() {
  gapsVisible = !gapsVisible;
  gapMeshes.forEach(m => m.visible = gapsVisible);
  this.textContent = gapsVisible ? 'Gaps ON' : 'Gaps OFF';
  this.classList.toggle('active', gapsVisible);
});

// ─── Reset Camera ─────────────────────────────────────────────────────────────
document.getElementById('resetCamera').addEventListener('click', () => {
  spherical = { theta: 0, phi: Math.PI / 2, radius: 5 };
  target.set(0, 0, 0);
  updateCamera();
});

// ─── Timeline ────────────────────────────────────────────────────────────────
let frames       = [];
let currentFrame = 0;
let playing      = false;
let playInterval = null;

function addFrame(points, colors) {
  frames.push({ points, colors });
  const slider = document.getElementById('frame-slider');
  slider.disabled = false;
  slider.max = frames.length - 1;
  document.getElementById('frame-display').textContent = `${currentFrame} / ${frames.length - 1}`;
}

function setFrame(idx) {
  if (!frames.length) return;
  currentFrame = Math.max(0, Math.min(idx, frames.length - 1));
  const f   = frames[currentFrame];
  const src = showCompleted && completedCloud ? completedCloud : partialCloud;
  if (src) {
    const geo = src.geometry;
    geo.setAttribute('position', new THREE.Float32BufferAttribute(f.points, 3));
    geo.setAttribute('color',    new THREE.Float32BufferAttribute(f.colors,  3));
    geo.attributes.position.needsUpdate = true;
    geo.attributes.color.needsUpdate    = true;
  }
  document.getElementById('frame-slider').value = currentFrame;
  document.getElementById('frame-display').textContent = `${currentFrame} / ${frames.length - 1}`;
}

document.getElementById('frame-slider').addEventListener('input', e => setFrame(+e.target.value));

const playBtn = document.getElementById('play-btn');
playBtn.addEventListener('click', () => {
  playing = !playing;
  playBtn.textContent = playing ? '⏸ Pause' : '▶ Play';
  playBtn.classList.toggle('playing', playing);
  if (playing) {
    playInterval = setInterval(() => setFrame((currentFrame + 1) % Math.max(1, frames.length)), 100);
  } else {
    clearInterval(playInterval);
  }
});

// ─── File Loading ─────────────────────────────────────────────────────────────
let plyLoadCount = 0;

async function handleFile(file) {
  if (file.name.endsWith('.json')) {
    try {
      renderGaps(JSON.parse(await file.text()));
      document.getElementById('status').textContent = `Gaps reloaded from ${file.name}`;
    } catch {
      document.getElementById('status').textContent = 'Invalid JSON file';
    }
    return;
  }
  if (!file.name.endsWith('.ply')) return;

  document.getElementById('status').textContent = 'Loading...';
  const { points, colors, vertexCount } = await parsePLY(await file.arrayBuffer());
  const isCompleted = plyLoadCount >= 1;
  plyLoadCount++;
  renderPointCloud(points, colors, vertexCount, isCompleted);
}

document.getElementById('fileInput').addEventListener('change', async e => {
  for (const file of e.target.files) await handleFile(file);
});
document.body.addEventListener('dragover', e => e.preventDefault());
document.body.addEventListener('drop', async e => {
  e.preventDefault();
  for (const file of e.dataTransfer.files) await handleFile(file);
});

// ─── Resize ───────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// ─── Render Loop ─────────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);

  if (splitMode && partialCloud && completedCloud) {
    const w = window.innerWidth, h = window.innerHeight;
    renderer.setScissorTest(true);

    // Left — partial + gaps
    partialCloud.visible   = true;
    completedCloud.visible = false;
    gapMeshes.forEach(m => m.visible = gapsVisible);
    renderer.setViewport(0, 0, w / 2, h);
    renderer.setScissor( 0, 0, w / 2, h);
    renderer.render(scene, camera);

    // Right — completed, no gaps
    partialCloud.visible   = false;
    completedCloud.visible = true;
    gapMeshes.forEach(m => m.visible = false);
    renderer.setViewport(w / 2, 0, w / 2, h);
    renderer.setScissor( w / 2, 0, w / 2, h);
    renderer.render(scene, camera);

    renderer.setScissorTest(false);
  } else {
    renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
    renderer.render(scene, camera);
  }
}
animate();

// ─── Auto-Load ────────────────────────────────────────────────────────────────
// Load file from URL param: ?file=path/to/file.ply
// Or auto-load test.ply if available
(async () => {
  const params = new URLSearchParams(window.location.search);
  const fileUrl = params.get('file') || 'test.ply';
  
  try {
    const response = await fetch(fileUrl);
    if (!response.ok) return; // No auto-load file, user will drop one
    
    document.getElementById('status').textContent = 'Loading ' + fileUrl + '...';
    const buffer = await response.arrayBuffer();
    const { points, colors, vertexCount } = await parsePLY(buffer);
    renderPointCloud(points, colors, vertexCount, false);
    document.getElementById('status').textContent = vertexCount.toLocaleString() + ' pts · ' + fileUrl;
  } catch (e) {
    // Silent fail — user can manually load
    console.log('Auto-load not available:', e.message);
  }
})();
</script>
</body>
</html>
